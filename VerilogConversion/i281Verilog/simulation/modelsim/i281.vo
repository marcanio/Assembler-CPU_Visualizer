// Copyright (C) 2020  Intel Corporation. All rights reserved.
// Your use of Intel Corporation's design tools, logic functions 
// and other software and tools, and any partner logic 
// functions, and any output files from any of the foregoing 
// (including device programming or simulation files), and any 
// associated documentation or information are expressly subject 
// to the terms and conditions of the Intel Program License 
// Subscription Agreement, the Intel Quartus Prime License Agreement,
// the Intel FPGA IP License Agreement, or other applicable license
// agreement, including, without limitation, that your use is for
// the sole purpose of programming logic devices manufactured by
// Intel and sold by Intel or its authorized distributors.  Please
// refer to the applicable agreement for further details, at
// https://fpgasoftware.intel.com/eula.

// VENDOR "Altera"
// PROGRAM "Quartus Prime"
// VERSION "Version 20.1.0 Build 711 06/05/2020 SJ Lite Edition"

// DATE "10/08/2020 21:47:32"

// 
// Device: Altera EP4CE115F29C7 Package FBGA780
// 

// 
// This Verilog file should be used for ModelSim-Altera (Verilog) only
// 

`timescale 1 ps/ 1 ps

module _Control_FSM (
	BRGE,
	BRG,
	BRNE_BRNZ,
	BRE_BRZ,
	JUMP,
	CMP,
	SHIFTR,
	SHIFTL,
	STOREF,
	STORE,
	LOADF,
	LOAD,
	SUBI,
	SUB,
	ADDI,
	ADD,
	LOADI_LOADP,
	MOVE,
	INPUT_DATADF,
	INPUT_DATAD,
	INPUT_DATACF,
	INPUT_DATAC,
	NOOP,
	X,
	Y,
	CARRY_FLAG,
	OVERFLOW_FLAG,
	NEGATIVE_FLAG,
	ZERO_FLAG,
	IMEM_WRITE_ENABLE,
	PC_MUX,
	PC_WRITE_ENABLE,
	REG_PORT0_SELECT,
	REG_PORT1_SELECT,
	REG_WRITE_SELECT,
	REG_WRITE_ENABLE,
	ALU_SOURCE_MUX,
	ALU_SELECT0,
	ALU_SELECT1,
	FLAGS_WRITE_ENABLE,
	ALU_RESULT_MUX,
	DMEM_INPUT_MUX,
	DMEM_WRITE_ENABLE,
	REG_WRITEBACK_MUX);
input 	BRGE;
input 	BRG;
input 	BRNE_BRNZ;
input 	BRE_BRZ;
input 	JUMP;
input 	CMP;
input 	SHIFTR;
input 	SHIFTL;
input 	STOREF;
input 	STORE;
input 	LOADF;
input 	LOAD;
input 	SUBI;
input 	SUB;
input 	ADDI;
input 	ADD;
input 	LOADI_LOADP;
input 	MOVE;
input 	INPUT_DATADF;
input 	INPUT_DATAD;
input 	INPUT_DATACF;
input 	INPUT_DATAC;
input 	NOOP;
input 	[1:0] X;
input 	[1:0] Y;
input 	CARRY_FLAG;
input 	OVERFLOW_FLAG;
input 	NEGATIVE_FLAG;
input 	ZERO_FLAG;
output 	IMEM_WRITE_ENABLE;
output 	PC_MUX;
output 	PC_WRITE_ENABLE;
output 	[1:0] REG_PORT0_SELECT;
output 	[1:0] REG_PORT1_SELECT;
output 	[1:0] REG_WRITE_SELECT;
output 	REG_WRITE_ENABLE;
output 	ALU_SOURCE_MUX;
output 	ALU_SELECT0;
output 	ALU_SELECT1;
output 	FLAGS_WRITE_ENABLE;
output 	ALU_RESULT_MUX;
output 	DMEM_INPUT_MUX;
output 	DMEM_WRITE_ENABLE;
output 	REG_WRITEBACK_MUX;

// Design Ports Information
// LOAD	=>  Location: PIN_AB1,	 I/O Standard: 2.5 V,	 Current Strength: Default
// LOADI_LOADP	=>  Location: PIN_AE10,	 I/O Standard: 2.5 V,	 Current Strength: Default
// INPUT_DATAD	=>  Location: PIN_AD28,	 I/O Standard: 2.5 V,	 Current Strength: Default
// NOOP	=>  Location: PIN_AG8,	 I/O Standard: 2.5 V,	 Current Strength: Default
// CARRY_FLAG	=>  Location: PIN_AB19,	 I/O Standard: 2.5 V,	 Current Strength: Default
// IMEM_WRITE_ENABLE	=>  Location: PIN_AE6,	 I/O Standard: 2.5 V,	 Current Strength: Default
// PC_MUX	=>  Location: PIN_J22,	 I/O Standard: 2.5 V,	 Current Strength: Default
// PC_WRITE_ENABLE	=>  Location: PIN_R2,	 I/O Standard: 2.5 V,	 Current Strength: Default
// REG_PORT0_SELECT[0]	=>  Location: PIN_AD7,	 I/O Standard: 2.5 V,	 Current Strength: Default
// REG_PORT0_SELECT[1]	=>  Location: PIN_AF6,	 I/O Standard: 2.5 V,	 Current Strength: Default
// REG_PORT1_SELECT[0]	=>  Location: PIN_AD5,	 I/O Standard: 2.5 V,	 Current Strength: Default
// REG_PORT1_SELECT[1]	=>  Location: PIN_AF3,	 I/O Standard: 2.5 V,	 Current Strength: Default
// REG_WRITE_SELECT[0]	=>  Location: PIN_Y17,	 I/O Standard: 2.5 V,	 Current Strength: Default
// REG_WRITE_SELECT[1]	=>  Location: PIN_C22,	 I/O Standard: 2.5 V,	 Current Strength: Default
// REG_WRITE_ENABLE	=>  Location: PIN_AH10,	 I/O Standard: 2.5 V,	 Current Strength: Default
// ALU_SOURCE_MUX	=>  Location: PIN_R28,	 I/O Standard: 2.5 V,	 Current Strength: Default
// ALU_SELECT0	=>  Location: PIN_Y19,	 I/O Standard: 2.5 V,	 Current Strength: Default
// ALU_SELECT1	=>  Location: PIN_E8,	 I/O Standard: 2.5 V,	 Current Strength: Default
// FLAGS_WRITE_ENABLE	=>  Location: PIN_G14,	 I/O Standard: 2.5 V,	 Current Strength: Default
// ALU_RESULT_MUX	=>  Location: PIN_AE24,	 I/O Standard: 2.5 V,	 Current Strength: Default
// DMEM_INPUT_MUX	=>  Location: PIN_AE12,	 I/O Standard: 2.5 V,	 Current Strength: Default
// DMEM_WRITE_ENABLE	=>  Location: PIN_C13,	 I/O Standard: 2.5 V,	 Current Strength: Default
// REG_WRITEBACK_MUX	=>  Location: PIN_AE28,	 I/O Standard: 2.5 V,	 Current Strength: Default
// INPUT_DATACF	=>  Location: PIN_AD4,	 I/O Standard: 2.5 V,	 Current Strength: Default
// INPUT_DATAC	=>  Location: PIN_AB6,	 I/O Standard: 2.5 V,	 Current Strength: Default
// JUMP	=>  Location: PIN_G26,	 I/O Standard: 2.5 V,	 Current Strength: Default
// BRE_BRZ	=>  Location: PIN_G25,	 I/O Standard: 2.5 V,	 Current Strength: Default
// BRNE_BRNZ	=>  Location: PIN_G24,	 I/O Standard: 2.5 V,	 Current Strength: Default
// ZERO_FLAG	=>  Location: PIN_H22,	 I/O Standard: 2.5 V,	 Current Strength: Default
// BRGE	=>  Location: PIN_H24,	 I/O Standard: 2.5 V,	 Current Strength: Default
// BRG	=>  Location: PIN_G23,	 I/O Standard: 2.5 V,	 Current Strength: Default
// OVERFLOW_FLAG	=>  Location: PIN_F24,	 I/O Standard: 2.5 V,	 Current Strength: Default
// NEGATIVE_FLAG	=>  Location: PIN_F25,	 I/O Standard: 2.5 V,	 Current Strength: Default
// STOREF	=>  Location: PIN_AE4,	 I/O Standard: 2.5 V,	 Current Strength: Default
// LOADF	=>  Location: PIN_AC7,	 I/O Standard: 2.5 V,	 Current Strength: Default
// MOVE	=>  Location: PIN_AH4,	 I/O Standard: 2.5 V,	 Current Strength: Default
// SHIFTR	=>  Location: PIN_AD8,	 I/O Standard: 2.5 V,	 Current Strength: Default
// SHIFTL	=>  Location: PIN_Y10,	 I/O Standard: 2.5 V,	 Current Strength: Default
// SUBI	=>  Location: PIN_AF4,	 I/O Standard: 2.5 V,	 Current Strength: Default
// ADDI	=>  Location: PIN_AB5,	 I/O Standard: 2.5 V,	 Current Strength: Default
// INPUT_DATADF	=>  Location: PIN_AC4,	 I/O Standard: 2.5 V,	 Current Strength: Default
// CMP	=>  Location: PIN_AG3,	 I/O Standard: 2.5 V,	 Current Strength: Default
// SUB	=>  Location: PIN_AF2,	 I/O Standard: 2.5 V,	 Current Strength: Default
// ADD	=>  Location: PIN_AB4,	 I/O Standard: 2.5 V,	 Current Strength: Default
// Y[0]	=>  Location: PIN_AE3,	 I/O Standard: 2.5 V,	 Current Strength: Default
// X[0]	=>  Location: PIN_AC5,	 I/O Standard: 2.5 V,	 Current Strength: Default
// Y[1]	=>  Location: PIN_AF5,	 I/O Standard: 2.5 V,	 Current Strength: Default
// X[1]	=>  Location: PIN_AH3,	 I/O Standard: 2.5 V,	 Current Strength: Default
// STORE	=>  Location: PIN_AE5,	 I/O Standard: 2.5 V,	 Current Strength: Default


wire gnd;
wire vcc;
wire unknown;

assign gnd = 1'b0;
assign vcc = 1'b1;
assign unknown = 1'bx;

tri1 devclrn;
tri1 devpor;
tri1 devoe;
wire \LOAD~input_o ;
wire \LOADI_LOADP~input_o ;
wire \INPUT_DATAD~input_o ;
wire \NOOP~input_o ;
wire \CARRY_FLAG~input_o ;
wire \IMEM_WRITE_ENABLE~output_o ;
wire \PC_MUX~output_o ;
wire \PC_WRITE_ENABLE~output_o ;
wire \REG_PORT0_SELECT[0]~output_o ;
wire \REG_PORT0_SELECT[1]~output_o ;
wire \REG_PORT1_SELECT[0]~output_o ;
wire \REG_PORT1_SELECT[1]~output_o ;
wire \REG_WRITE_SELECT[0]~output_o ;
wire \REG_WRITE_SELECT[1]~output_o ;
wire \REG_WRITE_ENABLE~output_o ;
wire \ALU_SOURCE_MUX~output_o ;
wire \ALU_SELECT0~output_o ;
wire \ALU_SELECT1~output_o ;
wire \FLAGS_WRITE_ENABLE~output_o ;
wire \ALU_RESULT_MUX~output_o ;
wire \DMEM_INPUT_MUX~output_o ;
wire \DMEM_WRITE_ENABLE~output_o ;
wire \REG_WRITEBACK_MUX~output_o ;
wire \INPUT_DATAC~input_o ;
wire \INPUT_DATACF~input_o ;
wire \IMEM_WRITE_ENABLE~0_combout ;
wire \OVERFLOW_FLAG~input_o ;
wire \ZERO_FLAG~input_o ;
wire \BRGE~input_o ;
wire \BRG~input_o ;
wire \OR75~1_combout ;
wire \JUMP~input_o ;
wire \BRE_BRZ~input_o ;
wire \BRNE_BRNZ~input_o ;
wire \OR75~0_combout ;
wire \NEGATIVE_FLAG~input_o ;
wire \OR75~2_combout ;
wire \Y[0]~input_o ;
wire \X[0]~input_o ;
wire \LOADF~input_o ;
wire \STOREF~input_o ;
wire \MOVE~input_o ;
wire \OR35~0_combout ;
wire \ADD~input_o ;
wire \SUB~input_o ;
wire \CMP~input_o ;
wire \OR22~0_combout ;
wire \INPUT_DATADF~input_o ;
wire \ADDI~input_o ;
wire \SUBI~input_o ;
wire \OR44~1_combout ;
wire \SHIFTL~input_o ;
wire \SHIFTR~input_o ;
wire \OR44~0_combout ;
wire \OR44~2_combout ;
wire \AND51~0_combout ;
wire \X[1]~input_o ;
wire \Y[1]~input_o ;
wire \AND49~0_combout ;
wire \STORE~input_o ;
wire \AND54~0_combout ;
wire \AND54~1_combout ;
wire \AND53~0_combout ;


hard_block auto_generated_inst(
	.devpor(devpor),
	.devclrn(devclrn),
	.devoe(devoe));

// Location: IOOBUF_X1_Y0_N16
cycloneive_io_obuf \IMEM_WRITE_ENABLE~output (
	.i(\IMEM_WRITE_ENABLE~0_combout ),
	.oe(vcc),
	.seriesterminationcontrol(16'b0000000000000000),
	.devoe(devoe),
	.o(\IMEM_WRITE_ENABLE~output_o ),
	.obar());
// synopsys translate_off
defparam \IMEM_WRITE_ENABLE~output .bus_hold = "false";
defparam \IMEM_WRITE_ENABLE~output .open_drain_output = "false";
// synopsys translate_on

// Location: IOOBUF_X115_Y67_N16
cycloneive_io_obuf \PC_MUX~output (
	.i(\OR75~2_combout ),
	.oe(vcc),
	.seriesterminationcontrol(16'b0000000000000000),
	.devoe(devoe),
	.o(\PC_MUX~output_o ),
	.obar());
// synopsys translate_off
defparam \PC_MUX~output .bus_hold = "false";
defparam \PC_MUX~output .open_drain_output = "false";
// synopsys translate_on

// Location: IOOBUF_X0_Y35_N2
cycloneive_io_obuf \PC_WRITE_ENABLE~output (
	.i(vcc),
	.oe(vcc),
	.seriesterminationcontrol(16'b0000000000000000),
	.devoe(devoe),
	.o(\PC_WRITE_ENABLE~output_o ),
	.obar());
// synopsys translate_off
defparam \PC_WRITE_ENABLE~output .bus_hold = "false";
defparam \PC_WRITE_ENABLE~output .open_drain_output = "false";
// synopsys translate_on

// Location: IOOBUF_X3_Y0_N2
cycloneive_io_obuf \REG_PORT0_SELECT[0]~output (
	.i(\AND51~0_combout ),
	.oe(vcc),
	.seriesterminationcontrol(16'b0000000000000000),
	.devoe(devoe),
	.o(\REG_PORT0_SELECT[0]~output_o ),
	.obar());
// synopsys translate_off
defparam \REG_PORT0_SELECT[0]~output .bus_hold = "false";
defparam \REG_PORT0_SELECT[0]~output .open_drain_output = "false";
// synopsys translate_on

// Location: IOOBUF_X7_Y0_N16
cycloneive_io_obuf \REG_PORT0_SELECT[1]~output (
	.i(\AND49~0_combout ),
	.oe(vcc),
	.seriesterminationcontrol(16'b0000000000000000),
	.devoe(devoe),
	.o(\REG_PORT0_SELECT[1]~output_o ),
	.obar());
// synopsys translate_off
defparam \REG_PORT0_SELECT[1]~output .bus_hold = "false";
defparam \REG_PORT0_SELECT[1]~output .open_drain_output = "false";
// synopsys translate_on

// Location: IOOBUF_X1_Y0_N23
cycloneive_io_obuf \REG_PORT1_SELECT[0]~output (
	.i(\AND54~1_combout ),
	.oe(vcc),
	.seriesterminationcontrol(16'b0000000000000000),
	.devoe(devoe),
	.o(\REG_PORT1_SELECT[0]~output_o ),
	.obar());
// synopsys translate_off
defparam \REG_PORT1_SELECT[0]~output .bus_hold = "false";
defparam \REG_PORT1_SELECT[0]~output .open_drain_output = "false";
// synopsys translate_on

// Location: IOOBUF_X7_Y0_N23
cycloneive_io_obuf \REG_PORT1_SELECT[1]~output (
	.i(\AND53~0_combout ),
	.oe(vcc),
	.seriesterminationcontrol(16'b0000000000000000),
	.devoe(devoe),
	.o(\REG_PORT1_SELECT[1]~output_o ),
	.obar());
// synopsys translate_off
defparam \REG_PORT1_SELECT[1]~output .bus_hold = "false";
defparam \REG_PORT1_SELECT[1]~output .open_drain_output = "false";
// synopsys translate_on

// Location: IOOBUF_X96_Y0_N23
cycloneive_io_obuf \REG_WRITE_SELECT[0]~output (
	.i(gnd),
	.oe(vcc),
	.seriesterminationcontrol(16'b0000000000000000),
	.devoe(devoe),
	.o(\REG_WRITE_SELECT[0]~output_o ),
	.obar());
// synopsys translate_off
defparam \REG_WRITE_SELECT[0]~output .bus_hold = "false";
defparam \REG_WRITE_SELECT[0]~output .open_drain_output = "false";
// synopsys translate_on

// Location: IOOBUF_X96_Y73_N16
cycloneive_io_obuf \REG_WRITE_SELECT[1]~output (
	.i(gnd),
	.oe(vcc),
	.seriesterminationcontrol(16'b0000000000000000),
	.devoe(devoe),
	.o(\REG_WRITE_SELECT[1]~output_o ),
	.obar());
// synopsys translate_off
defparam \REG_WRITE_SELECT[1]~output .bus_hold = "false";
defparam \REG_WRITE_SELECT[1]~output .open_drain_output = "false";
// synopsys translate_on

// Location: IOOBUF_X31_Y0_N2
cycloneive_io_obuf \REG_WRITE_ENABLE~output (
	.i(gnd),
	.oe(vcc),
	.seriesterminationcontrol(16'b0000000000000000),
	.devoe(devoe),
	.o(\REG_WRITE_ENABLE~output_o ),
	.obar());
// synopsys translate_off
defparam \REG_WRITE_ENABLE~output .bus_hold = "false";
defparam \REG_WRITE_ENABLE~output .open_drain_output = "false";
// synopsys translate_on

// Location: IOOBUF_X115_Y34_N23
cycloneive_io_obuf \ALU_SOURCE_MUX~output (
	.i(gnd),
	.oe(vcc),
	.seriesterminationcontrol(16'b0000000000000000),
	.devoe(devoe),
	.o(\ALU_SOURCE_MUX~output_o ),
	.obar());
// synopsys translate_off
defparam \ALU_SOURCE_MUX~output .bus_hold = "false";
defparam \ALU_SOURCE_MUX~output .open_drain_output = "false";
// synopsys translate_on

// Location: IOOBUF_X105_Y0_N2
cycloneive_io_obuf \ALU_SELECT0~output (
	.i(gnd),
	.oe(vcc),
	.seriesterminationcontrol(16'b0000000000000000),
	.devoe(devoe),
	.o(\ALU_SELECT0~output_o ),
	.obar());
// synopsys translate_off
defparam \ALU_SELECT0~output .bus_hold = "false";
defparam \ALU_SELECT0~output .open_drain_output = "false";
// synopsys translate_on

// Location: IOOBUF_X11_Y73_N2
cycloneive_io_obuf \ALU_SELECT1~output (
	.i(gnd),
	.oe(vcc),
	.seriesterminationcontrol(16'b0000000000000000),
	.devoe(devoe),
	.o(\ALU_SELECT1~output_o ),
	.obar());
// synopsys translate_off
defparam \ALU_SELECT1~output .bus_hold = "false";
defparam \ALU_SELECT1~output .open_drain_output = "false";
// synopsys translate_on

// Location: IOOBUF_X47_Y73_N16
cycloneive_io_obuf \FLAGS_WRITE_ENABLE~output (
	.i(gnd),
	.oe(vcc),
	.seriesterminationcontrol(16'b0000000000000000),
	.devoe(devoe),
	.o(\FLAGS_WRITE_ENABLE~output_o ),
	.obar());
// synopsys translate_off
defparam \FLAGS_WRITE_ENABLE~output .bus_hold = "false";
defparam \FLAGS_WRITE_ENABLE~output .open_drain_output = "false";
// synopsys translate_on

// Location: IOOBUF_X100_Y0_N16
cycloneive_io_obuf \ALU_RESULT_MUX~output (
	.i(gnd),
	.oe(vcc),
	.seriesterminationcontrol(16'b0000000000000000),
	.devoe(devoe),
	.o(\ALU_RESULT_MUX~output_o ),
	.obar());
// synopsys translate_off
defparam \ALU_RESULT_MUX~output .bus_hold = "false";
defparam \ALU_RESULT_MUX~output .open_drain_output = "false";
// synopsys translate_on

// Location: IOOBUF_X33_Y0_N9
cycloneive_io_obuf \DMEM_INPUT_MUX~output (
	.i(gnd),
	.oe(vcc),
	.seriesterminationcontrol(16'b0000000000000000),
	.devoe(devoe),
	.o(\DMEM_INPUT_MUX~output_o ),
	.obar());
// synopsys translate_off
defparam \DMEM_INPUT_MUX~output .bus_hold = "false";
defparam \DMEM_INPUT_MUX~output .open_drain_output = "false";
// synopsys translate_on

// Location: IOOBUF_X54_Y73_N2
cycloneive_io_obuf \DMEM_WRITE_ENABLE~output (
	.i(gnd),
	.oe(vcc),
	.seriesterminationcontrol(16'b0000000000000000),
	.devoe(devoe),
	.o(\DMEM_WRITE_ENABLE~output_o ),
	.obar());
// synopsys translate_off
defparam \DMEM_WRITE_ENABLE~output .bus_hold = "false";
defparam \DMEM_WRITE_ENABLE~output .open_drain_output = "false";
// synopsys translate_on

// Location: IOOBUF_X115_Y11_N2
cycloneive_io_obuf \REG_WRITEBACK_MUX~output (
	.i(gnd),
	.oe(vcc),
	.seriesterminationcontrol(16'b0000000000000000),
	.devoe(devoe),
	.o(\REG_WRITEBACK_MUX~output_o ),
	.obar());
// synopsys translate_off
defparam \REG_WRITEBACK_MUX~output .bus_hold = "false";
defparam \REG_WRITEBACK_MUX~output .open_drain_output = "false";
// synopsys translate_on

// Location: IOIBUF_X0_Y4_N8
cycloneive_io_ibuf \INPUT_DATAC~input (
	.i(INPUT_DATAC),
	.ibar(gnd),
	.o(\INPUT_DATAC~input_o ));
// synopsys translate_off
defparam \INPUT_DATAC~input .bus_hold = "false";
defparam \INPUT_DATAC~input .simulate_z_as = "z";
// synopsys translate_on

// Location: IOIBUF_X1_Y0_N8
cycloneive_io_ibuf \INPUT_DATACF~input (
	.i(INPUT_DATACF),
	.ibar(gnd),
	.o(\INPUT_DATACF~input_o ));
// synopsys translate_off
defparam \INPUT_DATACF~input .bus_hold = "false";
defparam \INPUT_DATACF~input .simulate_z_as = "z";
// synopsys translate_on

// Location: LCCOMB_X1_Y4_N0
cycloneive_lcell_comb \IMEM_WRITE_ENABLE~0 (
// Equation(s):
// \IMEM_WRITE_ENABLE~0_combout  = (\INPUT_DATAC~input_o ) # (\INPUT_DATACF~input_o )

	.dataa(\INPUT_DATAC~input_o ),
	.datab(gnd),
	.datac(gnd),
	.datad(\INPUT_DATACF~input_o ),
	.cin(gnd),
	.combout(\IMEM_WRITE_ENABLE~0_combout ),
	.cout());
// synopsys translate_off
defparam \IMEM_WRITE_ENABLE~0 .lut_mask = 16'hFFAA;
defparam \IMEM_WRITE_ENABLE~0 .sum_lutc_input = "datac";
// synopsys translate_on

// Location: IOIBUF_X115_Y68_N15
cycloneive_io_ibuf \OVERFLOW_FLAG~input (
	.i(OVERFLOW_FLAG),
	.ibar(gnd),
	.o(\OVERFLOW_FLAG~input_o ));
// synopsys translate_off
defparam \OVERFLOW_FLAG~input .bus_hold = "false";
defparam \OVERFLOW_FLAG~input .simulate_z_as = "z";
// synopsys translate_on

// Location: IOIBUF_X115_Y69_N1
cycloneive_io_ibuf \ZERO_FLAG~input (
	.i(ZERO_FLAG),
	.ibar(gnd),
	.o(\ZERO_FLAG~input_o ));
// synopsys translate_off
defparam \ZERO_FLAG~input .bus_hold = "false";
defparam \ZERO_FLAG~input .simulate_z_as = "z";
// synopsys translate_on

// Location: IOIBUF_X115_Y65_N22
cycloneive_io_ibuf \BRGE~input (
	.i(BRGE),
	.ibar(gnd),
	.o(\BRGE~input_o ));
// synopsys translate_off
defparam \BRGE~input .bus_hold = "false";
defparam \BRGE~input .simulate_z_as = "z";
// synopsys translate_on

// Location: IOIBUF_X115_Y69_N15
cycloneive_io_ibuf \BRG~input (
	.i(BRG),
	.ibar(gnd),
	.o(\BRG~input_o ));
// synopsys translate_off
defparam \BRG~input .bus_hold = "false";
defparam \BRG~input .simulate_z_as = "z";
// synopsys translate_on

// Location: LCCOMB_X114_Y69_N2
cycloneive_lcell_comb \OR75~1 (
// Equation(s):
// \OR75~1_combout  = (\BRGE~input_o ) # ((!\ZERO_FLAG~input_o  & \BRG~input_o ))

	.dataa(\ZERO_FLAG~input_o ),
	.datab(gnd),
	.datac(\BRGE~input_o ),
	.datad(\BRG~input_o ),
	.cin(gnd),
	.combout(\OR75~1_combout ),
	.cout());
// synopsys translate_off
defparam \OR75~1 .lut_mask = 16'hF5F0;
defparam \OR75~1 .sum_lutc_input = "datac";
// synopsys translate_on

// Location: IOIBUF_X115_Y66_N22
cycloneive_io_ibuf \JUMP~input (
	.i(JUMP),
	.ibar(gnd),
	.o(\JUMP~input_o ));
// synopsys translate_off
defparam \JUMP~input .bus_hold = "false";
defparam \JUMP~input .simulate_z_as = "z";
// synopsys translate_on

// Location: IOIBUF_X115_Y66_N15
cycloneive_io_ibuf \BRE_BRZ~input (
	.i(BRE_BRZ),
	.ibar(gnd),
	.o(\BRE_BRZ~input_o ));
// synopsys translate_off
defparam \BRE_BRZ~input .bus_hold = "false";
defparam \BRE_BRZ~input .simulate_z_as = "z";
// synopsys translate_on

// Location: IOIBUF_X115_Y69_N22
cycloneive_io_ibuf \BRNE_BRNZ~input (
	.i(BRNE_BRNZ),
	.ibar(gnd),
	.o(\BRNE_BRNZ~input_o ));
// synopsys translate_off
defparam \BRNE_BRNZ~input .bus_hold = "false";
defparam \BRNE_BRNZ~input .simulate_z_as = "z";
// synopsys translate_on

// Location: LCCOMB_X114_Y69_N8
cycloneive_lcell_comb \OR75~0 (
// Equation(s):
// \OR75~0_combout  = (\JUMP~input_o ) # ((\ZERO_FLAG~input_o  & (\BRE_BRZ~input_o )) # (!\ZERO_FLAG~input_o  & ((\BRNE_BRNZ~input_o ))))

	.dataa(\JUMP~input_o ),
	.datab(\BRE_BRZ~input_o ),
	.datac(\BRNE_BRNZ~input_o ),
	.datad(\ZERO_FLAG~input_o ),
	.cin(gnd),
	.combout(\OR75~0_combout ),
	.cout());
// synopsys translate_off
defparam \OR75~0 .lut_mask = 16'hEEFA;
defparam \OR75~0 .sum_lutc_input = "datac";
// synopsys translate_on

// Location: IOIBUF_X115_Y68_N22
cycloneive_io_ibuf \NEGATIVE_FLAG~input (
	.i(NEGATIVE_FLAG),
	.ibar(gnd),
	.o(\NEGATIVE_FLAG~input_o ));
// synopsys translate_off
defparam \NEGATIVE_FLAG~input .bus_hold = "false";
defparam \NEGATIVE_FLAG~input .simulate_z_as = "z";
// synopsys translate_on

// Location: LCCOMB_X114_Y68_N8
cycloneive_lcell_comb \OR75~2 (
// Equation(s):
// \OR75~2_combout  = (\OR75~0_combout ) # ((\OR75~1_combout  & (\OVERFLOW_FLAG~input_o  $ (!\NEGATIVE_FLAG~input_o ))))

	.dataa(\OVERFLOW_FLAG~input_o ),
	.datab(\OR75~1_combout ),
	.datac(\OR75~0_combout ),
	.datad(\NEGATIVE_FLAG~input_o ),
	.cin(gnd),
	.combout(\OR75~2_combout ),
	.cout());
// synopsys translate_off
defparam \OR75~2 .lut_mask = 16'hF8F4;
defparam \OR75~2 .sum_lutc_input = "datac";
// synopsys translate_on

// Location: IOIBUF_X0_Y7_N8
cycloneive_io_ibuf \Y[0]~input (
	.i(Y[0]),
	.ibar(gnd),
	.o(\Y[0]~input_o ));
// synopsys translate_off
defparam \Y[0]~input .bus_hold = "false";
defparam \Y[0]~input .simulate_z_as = "z";
// synopsys translate_on

// Location: IOIBUF_X0_Y5_N15
cycloneive_io_ibuf \X[0]~input (
	.i(X[0]),
	.ibar(gnd),
	.o(\X[0]~input_o ));
// synopsys translate_off
defparam \X[0]~input .bus_hold = "false";
defparam \X[0]~input .simulate_z_as = "z";
// synopsys translate_on

// Location: IOIBUF_X9_Y0_N1
cycloneive_io_ibuf \LOADF~input (
	.i(LOADF),
	.ibar(gnd),
	.o(\LOADF~input_o ));
// synopsys translate_off
defparam \LOADF~input .bus_hold = "false";
defparam \LOADF~input .simulate_z_as = "z";
// synopsys translate_on

// Location: IOIBUF_X3_Y0_N22
cycloneive_io_ibuf \STOREF~input (
	.i(STOREF),
	.ibar(gnd),
	.o(\STOREF~input_o ));
// synopsys translate_off
defparam \STOREF~input .bus_hold = "false";
defparam \STOREF~input .simulate_z_as = "z";
// synopsys translate_on

// Location: IOIBUF_X9_Y0_N15
cycloneive_io_ibuf \MOVE~input (
	.i(MOVE),
	.ibar(gnd),
	.o(\MOVE~input_o ));
// synopsys translate_off
defparam \MOVE~input .bus_hold = "false";
defparam \MOVE~input .simulate_z_as = "z";
// synopsys translate_on

// Location: LCCOMB_X4_Y4_N22
cycloneive_lcell_comb \OR35~0 (
// Equation(s):
// \OR35~0_combout  = (\LOADF~input_o ) # ((\STOREF~input_o ) # (\MOVE~input_o ))

	.dataa(\LOADF~input_o ),
	.datab(gnd),
	.datac(\STOREF~input_o ),
	.datad(\MOVE~input_o ),
	.cin(gnd),
	.combout(\OR35~0_combout ),
	.cout());
// synopsys translate_off
defparam \OR35~0 .lut_mask = 16'hFFFA;
defparam \OR35~0 .sum_lutc_input = "datac";
// synopsys translate_on

// Location: IOIBUF_X0_Y8_N22
cycloneive_io_ibuf \ADD~input (
	.i(ADD),
	.ibar(gnd),
	.o(\ADD~input_o ));
// synopsys translate_off
defparam \ADD~input .bus_hold = "false";
defparam \ADD~input .simulate_z_as = "z";
// synopsys translate_on

// Location: IOIBUF_X0_Y6_N1
cycloneive_io_ibuf \SUB~input (
	.i(SUB),
	.ibar(gnd),
	.o(\SUB~input_o ));
// synopsys translate_off
defparam \SUB~input .bus_hold = "false";
defparam \SUB~input .simulate_z_as = "z";
// synopsys translate_on

// Location: IOIBUF_X3_Y0_N15
cycloneive_io_ibuf \CMP~input (
	.i(CMP),
	.ibar(gnd),
	.o(\CMP~input_o ));
// synopsys translate_off
defparam \CMP~input .bus_hold = "false";
defparam \CMP~input .simulate_z_as = "z";
// synopsys translate_on

// Location: LCCOMB_X4_Y4_N26
cycloneive_lcell_comb \OR22~0 (
// Equation(s):
// \OR22~0_combout  = (!\ADD~input_o  & (!\SUB~input_o  & !\CMP~input_o ))

	.dataa(\ADD~input_o ),
	.datab(gnd),
	.datac(\SUB~input_o ),
	.datad(\CMP~input_o ),
	.cin(gnd),
	.combout(\OR22~0_combout ),
	.cout());
// synopsys translate_off
defparam \OR22~0 .lut_mask = 16'h0005;
defparam \OR22~0 .sum_lutc_input = "datac";
// synopsys translate_on

// Location: IOIBUF_X0_Y4_N1
cycloneive_io_ibuf \INPUT_DATADF~input (
	.i(INPUT_DATADF),
	.ibar(gnd),
	.o(\INPUT_DATADF~input_o ));
// synopsys translate_off
defparam \INPUT_DATADF~input .bus_hold = "false";
defparam \INPUT_DATADF~input .simulate_z_as = "z";
// synopsys translate_on

// Location: IOIBUF_X0_Y4_N22
cycloneive_io_ibuf \ADDI~input (
	.i(ADDI),
	.ibar(gnd),
	.o(\ADDI~input_o ));
// synopsys translate_off
defparam \ADDI~input .bus_hold = "false";
defparam \ADDI~input .simulate_z_as = "z";
// synopsys translate_on

// Location: IOIBUF_X1_Y0_N1
cycloneive_io_ibuf \SUBI~input (
	.i(SUBI),
	.ibar(gnd),
	.o(\SUBI~input_o ));
// synopsys translate_off
defparam \SUBI~input .bus_hold = "false";
defparam \SUBI~input .simulate_z_as = "z";
// synopsys translate_on

// Location: LCCOMB_X1_Y4_N26
cycloneive_lcell_comb \OR44~1 (
// Equation(s):
// \OR44~1_combout  = (\INPUT_DATADF~input_o ) # ((\ADDI~input_o ) # ((\SUBI~input_o ) # (\INPUT_DATACF~input_o )))

	.dataa(\INPUT_DATADF~input_o ),
	.datab(\ADDI~input_o ),
	.datac(\SUBI~input_o ),
	.datad(\INPUT_DATACF~input_o ),
	.cin(gnd),
	.combout(\OR44~1_combout ),
	.cout());
// synopsys translate_off
defparam \OR44~1 .lut_mask = 16'hFFFE;
defparam \OR44~1 .sum_lutc_input = "datac";
// synopsys translate_on

// Location: IOIBUF_X7_Y0_N8
cycloneive_io_ibuf \SHIFTL~input (
	.i(SHIFTL),
	.ibar(gnd),
	.o(\SHIFTL~input_o ));
// synopsys translate_off
defparam \SHIFTL~input .bus_hold = "false";
defparam \SHIFTL~input .simulate_z_as = "z";
// synopsys translate_on

// Location: IOIBUF_X9_Y0_N8
cycloneive_io_ibuf \SHIFTR~input (
	.i(SHIFTR),
	.ibar(gnd),
	.o(\SHIFTR~input_o ));
// synopsys translate_off
defparam \SHIFTR~input .bus_hold = "false";
defparam \SHIFTR~input .simulate_z_as = "z";
// synopsys translate_on

// Location: LCCOMB_X4_Y4_N24
cycloneive_lcell_comb \OR44~0 (
// Equation(s):
// \OR44~0_combout  = (\LOADF~input_o ) # ((\SHIFTR~input_o ) # ((\STOREF~input_o ) # (\MOVE~input_o )))

	.dataa(\LOADF~input_o ),
	.datab(\SHIFTR~input_o ),
	.datac(\STOREF~input_o ),
	.datad(\MOVE~input_o ),
	.cin(gnd),
	.combout(\OR44~0_combout ),
	.cout());
// synopsys translate_off
defparam \OR44~0 .lut_mask = 16'hFFFE;
defparam \OR44~0 .sum_lutc_input = "datac";
// synopsys translate_on

// Location: LCCOMB_X4_Y4_N12
cycloneive_lcell_comb \OR44~2 (
// Equation(s):
// \OR44~2_combout  = ((\OR44~1_combout ) # ((\SHIFTL~input_o ) # (\OR44~0_combout ))) # (!\OR22~0_combout )

	.dataa(\OR22~0_combout ),
	.datab(\OR44~1_combout ),
	.datac(\SHIFTL~input_o ),
	.datad(\OR44~0_combout ),
	.cin(gnd),
	.combout(\OR44~2_combout ),
	.cout());
// synopsys translate_off
defparam \OR44~2 .lut_mask = 16'hFFFD;
defparam \OR44~2 .sum_lutc_input = "datac";
// synopsys translate_on

// Location: LCCOMB_X4_Y4_N16
cycloneive_lcell_comb \AND51~0 (
// Equation(s):
// \AND51~0_combout  = (\OR44~2_combout  & ((\OR35~0_combout  & (\Y[0]~input_o )) # (!\OR35~0_combout  & ((\X[0]~input_o )))))

	.dataa(\Y[0]~input_o ),
	.datab(\X[0]~input_o ),
	.datac(\OR35~0_combout ),
	.datad(\OR44~2_combout ),
	.cin(gnd),
	.combout(\AND51~0_combout ),
	.cout());
// synopsys translate_off
defparam \AND51~0 .lut_mask = 16'hAC00;
defparam \AND51~0 .sum_lutc_input = "datac";
// synopsys translate_on

// Location: IOIBUF_X5_Y0_N8
cycloneive_io_ibuf \X[1]~input (
	.i(X[1]),
	.ibar(gnd),
	.o(\X[1]~input_o ));
// synopsys translate_off
defparam \X[1]~input .bus_hold = "false";
defparam \X[1]~input .simulate_z_as = "z";
// synopsys translate_on

// Location: IOIBUF_X5_Y0_N15
cycloneive_io_ibuf \Y[1]~input (
	.i(Y[1]),
	.ibar(gnd),
	.o(\Y[1]~input_o ));
// synopsys translate_off
defparam \Y[1]~input .bus_hold = "false";
defparam \Y[1]~input .simulate_z_as = "z";
// synopsys translate_on

// Location: LCCOMB_X4_Y4_N10
cycloneive_lcell_comb \AND49~0 (
// Equation(s):
// \AND49~0_combout  = (\OR44~2_combout  & ((\OR35~0_combout  & ((\Y[1]~input_o ))) # (!\OR35~0_combout  & (\X[1]~input_o ))))

	.dataa(\OR35~0_combout ),
	.datab(\X[1]~input_o ),
	.datac(\Y[1]~input_o ),
	.datad(\OR44~2_combout ),
	.cin(gnd),
	.combout(\AND49~0_combout ),
	.cout());
// synopsys translate_off
defparam \AND49~0 .lut_mask = 16'hE400;
defparam \AND49~0 .sum_lutc_input = "datac";
// synopsys translate_on

// Location: IOIBUF_X5_Y0_N22
cycloneive_io_ibuf \STORE~input (
	.i(STORE),
	.ibar(gnd),
	.o(\STORE~input_o ));
// synopsys translate_off
defparam \STORE~input .bus_hold = "false";
defparam \STORE~input .simulate_z_as = "z";
// synopsys translate_on

// Location: LCCOMB_X4_Y4_N28
cycloneive_lcell_comb \AND54~0 (
// Equation(s):
// \AND54~0_combout  = (\OR22~0_combout  & ((\STOREF~input_o ) # (\STORE~input_o )))

	.dataa(\OR22~0_combout ),
	.datab(gnd),
	.datac(\STOREF~input_o ),
	.datad(\STORE~input_o ),
	.cin(gnd),
	.combout(\AND54~0_combout ),
	.cout());
// synopsys translate_off
defparam \AND54~0 .lut_mask = 16'hAAA0;
defparam \AND54~0 .sum_lutc_input = "datac";
// synopsys translate_on

// Location: LCCOMB_X4_Y4_N14
cycloneive_lcell_comb \AND54~1 (
// Equation(s):
// \AND54~1_combout  = (\Y[0]~input_o  & (((\X[0]~input_o  & \AND54~0_combout )) # (!\OR22~0_combout ))) # (!\Y[0]~input_o  & (\X[0]~input_o  & ((\AND54~0_combout ))))

	.dataa(\Y[0]~input_o ),
	.datab(\X[0]~input_o ),
	.datac(\OR22~0_combout ),
	.datad(\AND54~0_combout ),
	.cin(gnd),
	.combout(\AND54~1_combout ),
	.cout());
// synopsys translate_off
defparam \AND54~1 .lut_mask = 16'hCE0A;
defparam \AND54~1 .sum_lutc_input = "datac";
// synopsys translate_on

// Location: LCCOMB_X4_Y4_N8
cycloneive_lcell_comb \AND53~0 (
// Equation(s):
// \AND53~0_combout  = (\OR22~0_combout  & (\AND54~0_combout  & ((\X[1]~input_o )))) # (!\OR22~0_combout  & ((\Y[1]~input_o ) # ((\AND54~0_combout  & \X[1]~input_o ))))

	.dataa(\OR22~0_combout ),
	.datab(\AND54~0_combout ),
	.datac(\Y[1]~input_o ),
	.datad(\X[1]~input_o ),
	.cin(gnd),
	.combout(\AND53~0_combout ),
	.cout());
// synopsys translate_off
defparam \AND53~0 .lut_mask = 16'hDC50;
defparam \AND53~0 .sum_lutc_input = "datac";
// synopsys translate_on

// Location: IOIBUF_X0_Y27_N22
cycloneive_io_ibuf \LOAD~input (
	.i(LOAD),
	.ibar(gnd),
	.o(\LOAD~input_o ));
// synopsys translate_off
defparam \LOAD~input .bus_hold = "false";
defparam \LOAD~input .simulate_z_as = "z";
// synopsys translate_on

// Location: IOIBUF_X29_Y0_N22
cycloneive_io_ibuf \LOADI_LOADP~input (
	.i(LOADI_LOADP),
	.ibar(gnd),
	.o(\LOADI_LOADP~input_o ));
// synopsys translate_off
defparam \LOADI_LOADP~input .bus_hold = "false";
defparam \LOADI_LOADP~input .simulate_z_as = "z";
// synopsys translate_on

// Location: IOIBUF_X115_Y12_N1
cycloneive_io_ibuf \INPUT_DATAD~input (
	.i(INPUT_DATAD),
	.ibar(gnd),
	.o(\INPUT_DATAD~input_o ));
// synopsys translate_off
defparam \INPUT_DATAD~input .bus_hold = "false";
defparam \INPUT_DATAD~input .simulate_z_as = "z";
// synopsys translate_on

// Location: IOIBUF_X18_Y0_N1
cycloneive_io_ibuf \NOOP~input (
	.i(NOOP),
	.ibar(gnd),
	.o(\NOOP~input_o ));
// synopsys translate_off
defparam \NOOP~input .bus_hold = "false";
defparam \NOOP~input .simulate_z_as = "z";
// synopsys translate_on

// Location: IOIBUF_X98_Y0_N22
cycloneive_io_ibuf \CARRY_FLAG~input (
	.i(CARRY_FLAG),
	.ibar(gnd),
	.o(\CARRY_FLAG~input_o ));
// synopsys translate_off
defparam \CARRY_FLAG~input .bus_hold = "false";
defparam \CARRY_FLAG~input .simulate_z_as = "z";
// synopsys translate_on

assign IMEM_WRITE_ENABLE = \IMEM_WRITE_ENABLE~output_o ;

assign PC_MUX = \PC_MUX~output_o ;

assign PC_WRITE_ENABLE = \PC_WRITE_ENABLE~output_o ;

assign REG_PORT0_SELECT[0] = \REG_PORT0_SELECT[0]~output_o ;

assign REG_PORT0_SELECT[1] = \REG_PORT0_SELECT[1]~output_o ;

assign REG_PORT1_SELECT[0] = \REG_PORT1_SELECT[0]~output_o ;

assign REG_PORT1_SELECT[1] = \REG_PORT1_SELECT[1]~output_o ;

assign REG_WRITE_SELECT[0] = \REG_WRITE_SELECT[0]~output_o ;

assign REG_WRITE_SELECT[1] = \REG_WRITE_SELECT[1]~output_o ;

assign REG_WRITE_ENABLE = \REG_WRITE_ENABLE~output_o ;

assign ALU_SOURCE_MUX = \ALU_SOURCE_MUX~output_o ;

assign ALU_SELECT0 = \ALU_SELECT0~output_o ;

assign ALU_SELECT1 = \ALU_SELECT1~output_o ;

assign FLAGS_WRITE_ENABLE = \FLAGS_WRITE_ENABLE~output_o ;

assign ALU_RESULT_MUX = \ALU_RESULT_MUX~output_o ;

assign DMEM_INPUT_MUX = \DMEM_INPUT_MUX~output_o ;

assign DMEM_WRITE_ENABLE = \DMEM_WRITE_ENABLE~output_o ;

assign REG_WRITEBACK_MUX = \REG_WRITEBACK_MUX~output_o ;

endmodule

module hard_block (

	devpor,
	devclrn,
	devoe);

// Design Ports Information
// ~ALTERA_ASDO_DATA1~	=>  Location: PIN_F4,	 I/O Standard: 2.5 V,	 Current Strength: Default
// ~ALTERA_FLASH_nCE_nCSO~	=>  Location: PIN_E2,	 I/O Standard: 2.5 V,	 Current Strength: Default
// ~ALTERA_DCLK~	=>  Location: PIN_P3,	 I/O Standard: 2.5 V,	 Current Strength: Default
// ~ALTERA_DATA0~	=>  Location: PIN_N7,	 I/O Standard: 2.5 V,	 Current Strength: Default
// ~ALTERA_nCEO~	=>  Location: PIN_P28,	 I/O Standard: 2.5 V,	 Current Strength: 8mA

input 	devpor;
input 	devclrn;
input 	devoe;

wire gnd;
wire vcc;
wire unknown;

assign gnd = 1'b0;
assign vcc = 1'b1;
assign unknown = 1'bx;

wire \~ALTERA_ASDO_DATA1~~padout ;
wire \~ALTERA_FLASH_nCE_nCSO~~padout ;
wire \~ALTERA_DATA0~~padout ;
wire \~ALTERA_ASDO_DATA1~~ibuf_o ;
wire \~ALTERA_FLASH_nCE_nCSO~~ibuf_o ;
wire \~ALTERA_DATA0~~ibuf_o ;


endmodule
